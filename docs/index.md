<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# internal

```go
import "github.com/cruciblehq/cruxd/internal"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func Arch\(\) string](<#Arch>)
- [func GitCommit\(\) string](<#GitCommit>)
- [func IsDebug\(\) bool](<#IsDebug>)
- [func IsLocal\(\) bool](<#IsLocal>)
- [func IsQuiet\(\) bool](<#IsQuiet>)
- [func IsVerbose\(\) bool](<#IsVerbose>)
- [func SetDebug\(enabled bool\)](<#SetDebug>)
- [func SetQuiet\(enabled bool\)](<#SetQuiet>)
- [func SetVerbose\(enabled bool\)](<#SetVerbose>)
- [func Stage\(\) string](<#Stage>)
- [func Version\(\) string](<#Version>)
- [func VersionString\(\) string](<#VersionString>)
- [func init\(\)](<#init>)


## Constants

<a name="defaultUndefined"></a>

```go
const (

    // String to indicate an undefined variable
    defaultUndefined = "(undefined)"

    // String to indicate a local (non-pipeline) build
    defaultLocalBuild = "(local)"

    // Main branch name used in version strings
    mainBranch = "main"
)
```

<a name="Name"></a>

```go
const (

    // Application name used in logging and identification.
    Name = "cruxd"
)
```

## Variables

<a name="quietMode"></a>

```go
var (
    quietMode   atomic.Bool // Indicates whether quiet mode is enabled.
    debugMode   atomic.Bool // Indicates whether debug logging is enabled.
    verboseMode atomic.Bool // Indicates whether verbose logging is enabled.
)
```

<a name="version"></a>

```go
var (
    version   = "" // Version number (e.g., "1.2.3")
    stage     = "" // Development stage or git branch (e.g., "staging", "main")
    gitCommit = "" // Git commit hash (e.g., "a1b2c3d4")

    rawQuiet   = "false" // Whether to enable quiet mode
    rawDebug   = "false" // Whether to enable debug mode
    rawVerbose = "false" // Whether to enable verbose logging
)
```

<a name="Arch"></a>
## func Arch

```go
func Arch() string
```

Returns the build architecture.

<a name="GitCommit"></a>
## func GitCommit

```go
func GitCommit() string
```

Returns the git commit hash.

If the commit hash is not set, returns "\(undefined\)".

<a name="IsDebug"></a>
## func IsDebug

```go
func IsDebug() bool
```

Returns true if debug mode is enabled.

<a name="IsLocal"></a>
## func IsLocal

```go
func IsLocal() bool
```

Returns true if this is a local \(non\-pipeline\) build.

A build is considered local if any of the version, git commit, or stage variables are unset. Pipeline builds should set all three variables via linker flags.

<a name="IsQuiet"></a>
## func IsQuiet

```go
func IsQuiet() bool
```

Returns true if quiet mode is enabled.

<a name="IsVerbose"></a>
## func IsVerbose

```go
func IsVerbose() bool
```

Returns true if verbose logging is enabled.

<a name="SetDebug"></a>
## func SetDebug

```go
func SetDebug(enabled bool)
```

Enables or disables debug mode.

<a name="SetQuiet"></a>
## func SetQuiet

```go
func SetQuiet(enabled bool)
```

Enables or disables quiet mode.

<a name="SetVerbose"></a>
## func SetVerbose

```go
func SetVerbose(enabled bool)
```

Enables or disables verbose logging.

<a name="Stage"></a>
## func Stage

```go
func Stage() string
```

Returns the development stage \(e.g., "alpha"\).

The development should correspond to the git branch name used during the build. If it is not set, returns "\(undefined\)".

<a name="Version"></a>
## func Version

```go
func Version() string
```

Returns the current version.

If the version is not set, returns "\(undefined\)". If the version includes a "v" or "V" prefix \(e.g., "v1.0.0"\), it is stripped.

<a name="VersionString"></a>
## func VersionString

```go
func VersionString() string
```

Returns a detailed version string.

If this is a local build, returns "\(local\)". Otherwise, returns a string formatted as "\<version\>\+\<stage\> \<git\-commit\> \[\<arch\>\]".

<a name="init"></a>
## func init

```go
func init()
```

Parses the linker flags into usable runtime variables.

The rawQuiet, rawDebug, and rawVerbose variables should be set via ldflags during the build process. If not set, they default to "false".

# cruxd

```go
import "github.com/cruciblehq/cruxd/cmd/cruxd"
```

## Index

- [func cwd\(\) string](<#cwd>)
- [func logLevel\(\) slog.Level](<#logLevel>)
- [func logger\(\) \*slog.Logger](<#logger>)
- [func main\(\)](<#main>)


<a name="cwd"></a>
## func cwd

```go
func cwd() string
```

Returns the current working directory or "\(unknown\)".

<a name="logLevel"></a>
## func logLevel

```go
func logLevel() slog.Level
```

Returns the log level derived from build\-time linker flags.

<a name="logger"></a>
## func logger

```go
func logger() *slog.Logger
```

Creates a buffered logger seeded from build\-time linker flags.

The logger is reconfigured after flag parsing via cli.Execute.

<a name="main"></a>
## func main

```go
func main()
```

The entry point for the cruxd daemon.

Initializes logging, displays startup information, and executes the root command. If any error occurs during execution, it exits with a non\-zero code.

# build

```go
import "github.com/cruciblehq/cruxd/internal/build"
```

Package build orchestrates recipe execution against container runtimes.

A recipe is an ordered sequence of stages, each backed by a container created from a base image. The build pipeline starts a container for each stage, dispatches its steps \(shell commands, file copies, and inter\-stage transfers\), and exports the final non\-transient stage as an OCI image. Multi\-platform builds repeat the pipeline per platform, writing each result to a platform\-specific output directory.

Container operations are delegated to the runtime package. Step state \(environment variables, working directory, shell\) is accumulated across steps within a stage and reset between stages.

Example usage:

```
result, err := build.Run(ctx, rt, build.Options{
    Recipe:    recipe,
    Resource:  "my-service",
    Output:    "dist",
    Root:      ".",
    Platforms: []string{"linux/amd64", "linux/arm64"},
})
if err != nil {
    return err
}
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func executeCopy\(ctx context.Context, ctr \*runtime.Container, copyStr, workdir, buildCtx string, stages map\[string\]\*runtime.Container\) error](<#executeCopy>)
- [func executeHostCopy\(ctx context.Context, ctr \*runtime.Container, src, dest, buildCtx string\) error](<#executeHostCopy>)
- [func executeOperation\(ctx context.Context, ctr \*runtime.Container, step manifest.Step, state \*stepState, buildCtx string, stages map\[string\]\*runtime.Container\) error](<#executeOperation>)
- [func executeStageCopy\(ctx context.Context, ctr \*runtime.Container, stages map\[string\]\*runtime.Container, stage, path, dest string\) error](<#executeStageCopy>)
- [func executeStep\(ctx context.Context, ctr \*runtime.Container, step manifest.Step, state \*stepState, buildCtx string, stages map\[string\]\*runtime.Container\) error](<#executeStep>)
- [func executeSteps\(ctx context.Context, ctr \*runtime.Container, steps \[\]manifest.Step, state \*stepState, buildCtx string, stages map\[string\]\*runtime.Container\) error](<#executeSteps>)
- [func parseCopy\(s, workdir string\) \(src, dest string, err error\)](<#parseCopy>)
- [func parseStageCopy\(src string\) \(stage, path string, ok bool\)](<#parseStageCopy>)
- [func platformSlug\(platform string\) string](<#platformSlug>)
- [func stageLabel\(name string, index int\) string](<#stageLabel>)
- [func writeDirToTar\(tw \*tar.Writer, hostDir, prefix string\) error](<#writeDirToTar>)
- [func writeFileToTar\(tw \*tar.Writer, hostPath, name string\) error](<#writeFileToTar>)
- [func writeTarEntry\(tw \*tar.Writer, hostPath, archivePath string, d os.DirEntry\) error](<#writeTarEntry>)
- [type Options](<#Options>)
- [type Result](<#Result>)
  - [func Run\(ctx context.Context, rt \*runtime.Runtime, opts Options\) \(\*Result, error\)](<#Run>)
- [type recipe](<#recipe>)
  - [func newRecipe\(rt \*runtime.Runtime, opts Options\) \*recipe](<#newRecipe>)
  - [func \(r \*recipe\) build\(ctx context.Context, recipeStages \[\]manifest.Stage\) \(\*Result, error\)](<#recipe.build>)
  - [func \(r \*recipe\) buildPlatform\(ctx context.Context, recipeStages \[\]manifest.Stage, platform string\) error](<#recipe.buildPlatform>)
  - [func \(r \*recipe\) buildStage\(ctx context.Context, stage manifest.Stage, index int, platform, output string, stages map\[string\]\*runtime.Container\) error](<#recipe.buildStage>)
  - [func \(r \*recipe\) containerID\(name string, index int, platform string\) string](<#recipe.containerID>)
  - [func \(r \*recipe\) destroyContainers\(ctx context.Context\)](<#recipe.destroyContainers>)
  - [func \(r \*recipe\) exportStage\(ctx context.Context, ctr \*runtime.Container, output string\) error](<#recipe.exportStage>)
  - [func \(r \*recipe\) platformOutput\(platform string\) string](<#recipe.platformOutput>)
  - [func \(r \*recipe\) resolveImageSource\(stage manifest.Stage\) \(manifest.Source, error\)](<#recipe.resolveImageSource>)
  - [func \(r \*recipe\) startStageContainer\(ctx context.Context, stage manifest.Stage, index int, platform string\) \(\*runtime.Container, error\)](<#recipe.startStageContainer>)
- [type stepState](<#stepState>)
  - [func newStepState\(\) \*stepState](<#newStepState>)
  - [func \(s \*stepState\) apply\(step manifest.Step\)](<#stepState.apply>)
  - [func \(s \*stepState\) environ\(\) \[\]string](<#stepState.environ>)
  - [func \(s \*stepState\) resolve\(step manifest.Step\) \*stepState](<#stepState.resolve>)


## Constants

<a name="defaultShell"></a>Default shell used for run steps when no shell modifier has been set.

```go
const defaultShell = "/bin/sh"
```

## Variables

<a name="ErrBuild"></a>

```go
var (
    ErrBuild               = errors.New("build failed")
    ErrCommandFailed       = errors.New("command failed")
    ErrFileSystemOperation = errors.New("file system operation failed")
    ErrCopy                = errors.New("copy failed")
)
```

<a name="executeCopy"></a>
## func executeCopy

```go
func executeCopy(ctx context.Context, ctr *runtime.Container, copyStr, workdir, buildCtx string, stages map[string]*runtime.Container) error
```

Executes a copy operation, transferring files into the container.

The copy string has the format "src dest" for host copies, or "stage:src dest" for cross\-stage copies. Host sources are resolved relative to the build context. Cross\-stage sources are read from a named stage container's filesystem.

<a name="executeHostCopy"></a>
## func executeHostCopy

```go
func executeHostCopy(ctx context.Context, ctr *runtime.Container, src, dest, buildCtx string) error
```

Copies a file or directory from the host into the container.

<a name="executeOperation"></a>
## func executeOperation

```go
func executeOperation(ctx context.Context, ctr *runtime.Container, step manifest.Step, state *stepState, buildCtx string, stages map[string]*runtime.Container) error
```

Executes a run or copy operation with scoped modifier overrides.

Step\-level modifiers override the persistent state for this operation only. The persistent state is not modified.

<a name="executeStageCopy"></a>
## func executeStageCopy

```go
func executeStageCopy(ctx context.Context, ctr *runtime.Container, stages map[string]*runtime.Container, stage, path, dest string) error
```

Copies a path from a named stage container into the target container.

The tar stream is piped directly from the source container's CopyFrom to the target container's CopyTo.

<a name="executeStep"></a>
## func executeStep

```go
func executeStep(ctx context.Context, ctr *runtime.Container, step manifest.Step, state *stepState, buildCtx string, stages map[string]*runtime.Container) error
```

Executes a single step, dispatching to operation execution, group recursion, or state mutation depending on the step's fields.

<a name="executeSteps"></a>
## func executeSteps

```go
func executeSteps(ctx context.Context, ctr *runtime.Container, steps []manifest.Step, state *stepState, buildCtx string, stages map[string]*runtime.Container) error
```

Executes a list of steps in order against the build container.

<a name="parseCopy"></a>
## func parseCopy

```go
func parseCopy(s, workdir string) (src, dest string, err error)
```

Parses a copy string into source and destination paths.

The string must contain exactly two whitespace\-separated tokens. If dest is not absolute, it is joined with workdir.

<a name="parseStageCopy"></a>
## func parseStageCopy

```go
func parseStageCopy(src string) (stage, path string, ok bool)
```

Parses a cross\-stage copy source of the form "stage:path".

Returns the stage name, the path within the stage, and true if the source matches the cross\-stage format. Returns false if it is a regular host path.

<a name="platformSlug"></a>
## func platformSlug

```go
func platformSlug(platform string) string
```

Converts a platform string to a filesystem\-safe slug.

Replaces slashes with dashes \(e.g., "linux/amd64" becomes "linux\-amd64"\).

<a name="stageLabel"></a>
## func stageLabel

```go
func stageLabel(name string, index int) string
```

Returns a label for a stage, preferring the name when available and falling back to the 1\-based index.

<a name="writeDirToTar"></a>
## func writeDirToTar

```go
func writeDirToTar(tw *tar.Writer, hostDir, prefix string) error
```

Writes a directory tree to a tar writer rooted at the given archive prefix.

<a name="writeFileToTar"></a>
## func writeFileToTar

```go
func writeFileToTar(tw *tar.Writer, hostPath, name string) error
```

Writes a single file to a tar writer with the given archive name.

<a name="writeTarEntry"></a>
## func writeTarEntry

```go
func writeTarEntry(tw *tar.Writer, hostPath, archivePath string, d os.DirEntry) error
```

Writes a single file or directory entry to a tar writer.

<a name="Options"></a>
## type Options

Controls recipe execution.

```go
type Options struct {
    Recipe     *manifest.Recipe // Recipe to execute.
    Resource   string           // Resource name, used as a prefix for container IDs.
    Output     string           // Directory for the exported image.
    Root       string           // Project root, for resolving copy sources.
    Entrypoint []string         // OCI entrypoint for the output image (services only).
    Platforms  []string         // Target platforms (e.g., ["linux/amd64"]). Defaults to host.
}
```

<a name="Result"></a>
## type Result

Returned after successful recipe execution.

```go
type Result struct {
    Output string // Directory containing the exported image.
}
```

<a name="Run"></a>
### func Run

```go
func Run(ctx context.Context, rt *runtime.Runtime, opts Options) (*Result, error)
```

Executes a recipe against the container runtime.

Stages are built in declaration order. Each stage starts a container from its base image, executes the stage's steps, and the non\-transient stage is exported as the final image to the output directory.

<a name="recipe"></a>
## type recipe

Holds shared state for building all stages of a recipe.

```go
type recipe struct {
    rt         *runtime.Runtime     // Container runtime for image and container operations.
    resource   string               // Resource name, used as a prefix for container IDs.
    output     string               // Output directory for the final build artifact.
    context    string               // Directory containing the manifest, root for resolving copy sources.
    entrypoint []string             // OCI entrypoint to set on the output image (services only).
    platforms  []string             // Target platforms to build for.
    containers []*runtime.Container // All stage containers across all platforms, destroyed after the build completes.
}
```

<a name="newRecipe"></a>
### func newRecipe

```go
func newRecipe(rt *runtime.Runtime, opts Options) *recipe
```

Creates a new \[recipe\] from the given options.

<a name="recipe.build"></a>
### func \(\*recipe\) build

```go
func (r *recipe) build(ctx context.Context, recipeStages []manifest.Stage) (*Result, error)
```

Builds the recipe end\-to\-end against the container runtime.

Each target platform is built independently. Stages are built in declaration order for each platform. The non\-transient stage is exported as the final image to the platform's output directory. All stage containers are destroyed when the build completes.

<a name="recipe.buildPlatform"></a>
### func \(\*recipe\) buildPlatform

```go
func (r *recipe) buildPlatform(ctx context.Context, recipeStages []manifest.Stage, platform string) error
```

Builds all stages of the recipe for a single platform.

Each platform maintains its own set of named stage containers for cross\-stage copy lookups. The output is written to a platform\-specific subdirectory when building for multiple platforms.

<a name="recipe.buildStage"></a>
### func \(\*recipe\) buildStage

```go
func (r *recipe) buildStage(ctx context.Context, stage manifest.Stage, index int, platform, output string, stages map[string]*runtime.Container) error
```

Builds a single stage of a recipe for a specific platform.

Resolves the stage's base image, starts a build container, executes the stage's steps, then commits the result. Non\-transient stages are exported to the output directory.

<a name="recipe.containerID"></a>
### func \(\*recipe\) containerID

```go
func (r *recipe) containerID(name string, index int, platform string) string
```

Returns a unique container ID for a stage, scoped to this resource and platform.

If resource namescontain any slashes \(e.g., "crucible/runtime\-go"\), they are replaced with dashes to ensure the resulting container ID is valid. The stage name is included when available for readability; otherwise, the 1\-based stage index is used.

<a name="recipe.destroyContainers"></a>
### func \(\*recipe\) destroyContainers

```go
func (r *recipe) destroyContainers(ctx context.Context)
```

Destroys all stage containers.

<a name="recipe.exportStage"></a>
### func \(\*recipe\) exportStage

```go
func (r *recipe) exportStage(ctx context.Context, ctr *runtime.Container, output string) error
```

Stops the container and exports it as the final image.

<a name="recipe.platformOutput"></a>
### func \(\*recipe\) platformOutput

```go
func (r *recipe) platformOutput(platform string) string
```

Returns the output directory for a specific platform.

When building for a single platform, the output directory is left as\-is to preserve the existing \{output\}/image.tar convention. For multi\-platform builds, each platform gets a subdirectory \(e.g., \{output\}/linux\-amd64\).

<a name="recipe.resolveImageSource"></a>
### func \(\*recipe\) resolveImageSource

```go
func (r *recipe) resolveImageSource(stage manifest.Stage) (manifest.Source, error)
```

Resolves the stage's base image source.

For file sources, relative paths are resolved against the build context directory. OCI references \(single\-token image names like "alpine:3.21"\) are returned as\-is for the runtime to pull from a container registry.

<a name="recipe.startStageContainer"></a>
### func \(\*recipe\) startStageContainer

```go
func (r *recipe) startStageContainer(ctx context.Context, stage manifest.Stage, index int, platform string) (*runtime.Container, error)
```

Resolves the base image source and starts the stage container.

<a name="stepState"></a>
## type stepState

Tracks accumulated modifiers during step execution.

State flows linearly through the step list. Standalone modifiers update the state permanently via apply. Operations read the effective values for a single step via resolve without modifying the persistent state.

```go
type stepState struct {
    shell   string
    workdir string
    env     map[string]string
}
```

<a name="newStepState"></a>
### func newStepState

```go
func newStepState() *stepState
```

Creates a new \[stepState\] with default values.

<a name="stepState.apply"></a>
### func \(\*stepState\) apply

```go
func (s *stepState) apply(step manifest.Step)
```

Persists modifier fields from a step into the state.

Called for standalone modifier steps and platform groups. The state is mutated permanently, affecting all subsequent steps.

<a name="stepState.environ"></a>
### func \(\*stepState\) environ

```go
func (s *stepState) environ() []string
```

Formats the environment as a list of "key=value" strings suitable for passing to container exec.

<a name="stepState.resolve"></a>
### func \(\*stepState\) resolve

```go
func (s *stepState) resolve(step manifest.Step) *stepState
```

Returns a new \[stepState\] with step\-level modifiers overlaid on the persistent state. The receiver is not modified.

Step\-level modifiers override the corresponding state values for this operation only.

# cli

```go
import "github.com/cruciblehq/cruxd/internal/cli"
```

Parses flags and configures logging for the cruxd daemon.

The daemon accepts the following flags:

```
-q, --quiet     Suppress informational output.
-v, --verbose   Enable verbose output.
-d, --debug     Enable debug output.
-s, --socket    Unix socket path.
```

Flags override build\-time defaults set via linker flags. After parsing, the global logger is reconfigured to reflect the final level and verbosity before the server starts.

## Index

- [Variables](<#variables>)
- [func Execute\(\) error](<#Execute>)
- [func configureLogger\(\)](<#configureLogger>)
- [func isatty\(f \*os.File\) bool](<#isatty>)
- [type StartCmd](<#StartCmd>)
  - [func \(c \*StartCmd\) Run\(ctx context.Context\) error](<#StartCmd.Run>)
- [type VersionCmd](<#VersionCmd>)
  - [func \(c \*VersionCmd\) Run\(ctx context.Context\) error](<#VersionCmd.Run>)


## Variables

<a name="RootCmd"></a>Represents the root command for the cruxd daemon.

```go
var RootCmd struct {
    Quiet   bool       `short:"q" help:"Suppress informational output."`
    Verbose bool       `short:"v" help:"Enable verbose output."`
    Debug   bool       `short:"d" help:"Enable debug output."`
    Socket  string     `short:"s" help:"Override the default Unix socket path." placeholder:"PATH"`
    Start   StartCmd   `cmd:"" help:"Start the daemon."`
    Version VersionCmd `cmd:"" help:"Show version information."`
}
```

<a name="Execute"></a>
## func Execute

```go
func Execute() error
```

Parses arguments, configures logging, and runs the selected subcommand.

<a name="configureLogger"></a>
## func configureLogger

```go
func configureLogger()
```

Configures the global logger based on CLI flags.

<a name="isatty"></a>
## func isatty

```go
func isatty(f *os.File) bool
```

Whether the given file is an interactive terminal.

<a name="StartCmd"></a>
## type StartCmd

Represents the 'cruxd start' command.

```go
type StartCmd struct{}
```

<a name="StartCmd.Run"></a>
### func \(\*StartCmd\) Run

```go
func (c *StartCmd) Run(ctx context.Context) error
```

Executes the start command.

Starts the gRPC server on a Unix domain socket and blocks until the context is cancelled \(e.g. via SIGINT or SIGTERM\).

<a name="VersionCmd"></a>
## type VersionCmd

Represents the 'cruxd version' command.

```go
type VersionCmd struct{}
```

<a name="VersionCmd.Run"></a>
### func \(\*VersionCmd\) Run

```go
func (c *VersionCmd) Run(ctx context.Context) error
```

Executes the version command.

# runtime

```go
import "github.com/cruciblehq/cruxd/internal/runtime"
```

Package runtime manages containers backed by containerd.

A [Runtime](<#Runtime>) connects to a containerd daemon and provides image import and container creation. OCI archives are imported, tagged with a deterministic content hash, unpacked for the target platform, and used to create containers with overlayfs snapshots.

Each [Container](<#Container>) wraps a running containerd task. Commands can be executed inside the container, files can be copied in and out as tar streams, and the final filesystem state can be committed and exported as a new OCI archive. When the container is no longer needed it should be destroyed to release its snapshot and task resources.

Example usage:

```
rt, err := runtime.New("/run/containerd/containerd.sock", "crucible")
if err != nil {
    return err
}
defer rt.Close()

ctr, err := rt.StartContainer(ctx, "image.tar", "build-1", "linux/amd64")
if err != nil {
    return err
}
defer ctr.Destroy(ctx)

result, err := ctr.Exec(ctx, "/bin/sh", "echo hello", nil, "")
if err != nil {
    return err
}

if err := ctr.Export(ctx, "output", []string{"/entrypoint"}); err != nil {
    return err
}
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func awaitProcess\(ctx context.Context, process containerd.Process, stdinDone \<\-chan struct\{\}\) \(int, error\)](<#awaitProcess>)
- [func defaultPlatform\(\) string](<#defaultPlatform>)
- [func imageTag\(path string\) string](<#imageTag>)
- [func indexGCLabels\(idx ocispec.Index\) map\[string\]string](<#indexGCLabels>)
- [func manifestGCLabels\(m ocispec.Manifest\) map\[string\]string](<#manifestGCLabels>)
- [func mergeEnv\(base, overrides \[\]string\) \[\]string](<#mergeEnv>)
- [func nextExecID\(\) string](<#nextExecID>)
- [type Container](<#Container>)
  - [func \(c \*Container\) CopyFrom\(ctx context.Context, w io.Writer, path string\) error](<#Container.CopyFrom>)
  - [func \(c \*Container\) CopyTo\(ctx context.Context, r io.Reader, destDir string\) error](<#Container.CopyTo>)
  - [func \(c \*Container\) Destroy\(ctx context.Context\)](<#Container.Destroy>)
  - [func \(c \*Container\) Exec\(ctx context.Context, shell, command string, env \[\]string, workdir string\) \(\*ExecResult, error\)](<#Container.Exec>)
  - [func \(c \*Container\) ExecArgs\(ctx context.Context, args \[\]string\) \(\*ExecResult, error\)](<#Container.ExecArgs>)
  - [func \(c \*Container\) Export\(ctx context.Context, output string, entrypoint \[\]string\) error](<#Container.Export>)
  - [func \(c \*Container\) MkdirAll\(ctx context.Context, path string\) error](<#Container.MkdirAll>)
  - [func \(c \*Container\) Start\(ctx context.Context\) error](<#Container.Start>)
  - [func \(c \*Container\) Status\(ctx context.Context\) \(protocol.ContainerState, error\)](<#Container.Status>)
  - [func \(c \*Container\) Stop\(ctx context.Context\) error](<#Container.Stop>)
  - [func \(c \*Container\) buildExportTarget\(ctx context.Context, imageName string, mutate func\(\*ocispec.Manifest, \*ocispec.Image\)\) \(ocispec.Descriptor, error\)](<#Container.buildExportTarget>)
  - [func \(c \*Container\) buildImageTarget\(ctx context.Context, root ocispec.Descriptor, index \*ocispec.Index, manifestIdx int, newManifest ocispec.Descriptor, imageName string\) \(ocispec.Descriptor, error\)](<#Container.buildImageTarget>)
  - [func \(c \*Container\) buildProcessSpec\(ctx context.Context, env \[\]string, workdir string, args ...string\) \(\*specs.Process, error\)](<#Container.buildProcessSpec>)
  - [func \(c \*Container\) configPlatform\(ctx context.Context, desc ocispec.Descriptor\) \(ocispec.Platform, bool\)](<#Container.configPlatform>)
  - [func \(c \*Container\) create\(ctx context.Context, image containerd.Image, extraOpts ...oci.SpecOpts\) \(containerd.Container, error\)](<#Container.create>)
  - [func \(c \*Container\) execCommand\(ctx context.Context, stdin io.Reader, stdout io.Writer, env \[\]string, workdir string, args ...string\) \(int, string, error\)](<#Container.execCommand>)
  - [func \(c \*Container\) execProcess\(ctx context.Context, pspec \*specs.Process, stdin io.Reader, stdout, stderr io.Writer\) \(int, error\)](<#Container.execProcess>)
  - [func \(c \*Container\) exportImage\(ctx context.Context, target ocispec.Descriptor, imageName, path string\) error](<#Container.exportImage>)
  - [func \(c \*Container\) loadTask\(ctx context.Context\) \(containerd.Task, error\)](<#Container.loadTask>)
  - [func \(c \*Container\) matchManifest\(ctx context.Context, idx ocispec.Index, matcher platforms.MatchComparer\) \(int, bool\)](<#Container.matchManifest>)
  - [func \(c \*Container\) mustExec\(ctx context.Context, desc string, stdin io.Reader, stdout io.Writer, args ...string\) error](<#Container.mustExec>)
  - [func \(c \*Container\) mutateManifest\(ctx context.Context, target ocispec.Descriptor, imageName string, mutate func\(\*ocispec.Manifest, \*ocispec.Image\)\) \(ocispec.Descriptor, error\)](<#Container.mutateManifest>)
  - [func \(c \*Container\) readConfig\(ctx context.Context, desc ocispec.Descriptor\) \(ocispec.Image, error\)](<#Container.readConfig>)
  - [func \(c \*Container\) readIndex\(ctx context.Context, desc ocispec.Descriptor\) \(ocispec.Index, error\)](<#Container.readIndex>)
  - [func \(c \*Container\) readManifest\(ctx context.Context, desc ocispec.Descriptor\) \(ocispec.Manifest, error\)](<#Container.readManifest>)
  - [func \(c \*Container\) remove\(ctx context.Context\)](<#Container.remove>)
  - [func \(c \*Container\) resolveManifestDescriptor\(ctx context.Context, root ocispec.Descriptor, imageName string\) \(ocispec.Descriptor, \*ocispec.Index, int, error\)](<#Container.resolveManifestDescriptor>)
  - [func \(c \*Container\) snapshotDiff\(ctx context.Context, info containers.Container\) \(ocispec.Descriptor, digest.Digest, error\)](<#Container.snapshotDiff>)
  - [func \(c \*Container\) startTask\(ctx context.Context, ctr containerd.Container\) error](<#Container.startTask>)
  - [func \(c \*Container\) writeBlob\(ctx context.Context, mediaType string, v any, ref string, opts ...content.Opt\) \(ocispec.Descriptor, error\)](<#Container.writeBlob>)
- [type ExecResult](<#ExecResult>)
- [type Runtime](<#Runtime>)
  - [func New\(address, namespace string\) \(\*Runtime, error\)](<#New>)
  - [func \(rt \*Runtime\) Close\(\) error](<#Runtime.Close>)
  - [func \(rt \*Runtime\) Container\(id string\) \*Container](<#Runtime.Container>)
  - [func \(rt \*Runtime\) DestroyImage\(ctx context.Context, tag string\) error](<#Runtime.DestroyImage>)
  - [func \(rt \*Runtime\) ImportImage\(ctx context.Context, path, tag string\) error](<#Runtime.ImportImage>)
  - [func \(rt \*Runtime\) StartContainer\(ctx context.Context, path string, id string, platform string\) \(\*Container, error\)](<#Runtime.StartContainer>)
  - [func \(rt \*Runtime\) StartContainerFromOCI\(ctx context.Context, ref string, id string, platform string\) \(\*Container, error\)](<#Runtime.StartContainerFromOCI>)
  - [func \(rt \*Runtime\) StartFromTag\(ctx context.Context, tag, id string\) \(\*Container, error\)](<#Runtime.StartFromTag>)
  - [func \(rt \*Runtime\) pullImage\(ctx context.Context, ref string, platform string\) \(containerd.Image, error\)](<#Runtime.pullImage>)
  - [func \(rt \*Runtime\) resolveImage\(ctx context.Context, tag, platform string\) \(containerd.Image, error\)](<#Runtime.resolveImage>)
  - [func \(rt \*Runtime\) transferImage\(ctx context.Context, path, tag, platform string\) error](<#Runtime.transferImage>)
- [type doneReader](<#doneReader>)
  - [func newDoneReader\(r io.Reader\) \*doneReader](<#newDoneReader>)
  - [func \(d \*doneReader\) Read\(p \[\]byte\) \(int, error\)](<#doneReader.Read>)


## Constants

<a name="snapshotter"></a>

```go
const (

    // Snapshotter used for container filesystems. containerd runs as root
    // inside the VM, so the native overlayfs kernel module is available.
    snapshotter = "overlayfs"

    // OCI runtime shim for running containers.
    ociRuntime = "io.containerd.runc.v2"
)
```

<a name="exportFilename"></a>Filename of the OCI archive produced by Export.

```go
const exportFilename = "image.tar"
```

## Variables

<a name="ErrRuntime"></a>

```go
var (
    ErrRuntime    = errors.New("runtime error")
    ErrEmptyIndex = errors.New("empty image index")
)
```

<a name="execSeq"></a>Sequence counter for generating unique exec process identifiers.

```go
var execSeq uint64
```

<a name="awaitProcess"></a>
## func awaitProcess

```go
func awaitProcess(ctx context.Context, process containerd.Process, stdinDone <-chan struct{}) (int, error)
```

Waits for an exec process to exit and returns the exit code.

The process is started, then the function blocks until it exits. If stdinDone is non\-nil, the process stdin is closed when the channel fires so the exec process receives EOF. The process is always deleted before returning.

<a name="defaultPlatform"></a>
## func defaultPlatform

```go
func defaultPlatform() string
```

Returns the default OCI platform for the host architecture.

<a name="imageTag"></a>
## func imageTag

```go
func imageTag(path string) string
```

Produces a containerd image tag from an archive path.

The path is hashed to produce a tag that is always valid for OCI references regardless of which characters the path contains.

<a name="indexGCLabels"></a>
## func indexGCLabels

```go
func indexGCLabels(idx ocispec.Index) map[string]string
```

Computes containerd GC reference labels for an index's children.

<a name="manifestGCLabels"></a>
## func manifestGCLabels

```go
func manifestGCLabels(m ocispec.Manifest) map[string]string
```

Computes containerd GC reference labels for a manifest's children.

These labels allow containerd's garbage collector to trace reachability from the manifest blob to its config and layer blobs.

<a name="mergeEnv"></a>
## func mergeEnv

```go
func mergeEnv(base, overrides []string) []string
```

Merges override env vars on top of a base env slice.

<a name="nextExecID"></a>
## func nextExecID

```go
func nextExecID() string
```

Returns a unique exec process identifier.

<a name="Container"></a>
## type Container

A running build container backed by containerd.

```go
type Container struct {
    client   *containerd.Client // Containerd client for managing the container.
    id       string             // Unique identifier for the container, used as the containerd container ID.
    platform string             // OCI platform (e.g., "linux/amd64").
}
```

<a name="Container.CopyFrom"></a>
### func \(\*Container\) CopyFrom

```go
func (c *Container) CopyFrom(ctx context.Context, w io.Writer, path string) error
```

Copies a path from the container's filesystem as a tar stream.

The file or directory at path is archived by running "tar cf \- \-C \<dir\> \<base\>" inside the container and streaming the output to w.

<a name="Container.CopyTo"></a>
### func \(\*Container\) CopyTo

```go
func (c *Container) CopyTo(ctx context.Context, r io.Reader, destDir string) error
```

Copies a tar stream into the container's filesystem.

The contents of r are extracted into destDir by piping them to "tar xf \- \-C destDir" inside the container.

<a name="Container.Destroy"></a>
### func \(\*Container\) Destroy

```go
func (c *Container) Destroy(ctx context.Context)
```

Removes the container and its resources.

The task is killed and the container is removed from containerd along with its snapshot. After destruction the handle is invalid.

<a name="Container.Exec"></a>
### func \(\*Container\) Exec

```go
func (c *Container) Exec(ctx context.Context, shell, command string, env []string, workdir string) (*ExecResult, error)
```

Runs a command inside the container.

The command is passed to the shell as a single argument via "shell \-c command". Environment variables and working directory override the container's OCI spec for this execution only.

<a name="Container.ExecArgs"></a>
### func \(\*Container\) ExecArgs

```go
func (c *Container) ExecArgs(ctx context.Context, args []string) (*ExecResult, error)
```

Runs a command and arguments directly inside the container.

Unlike \[Exec\], which passes a command string to a shell, ExecArgs runs the command directly without shell wrapping. This is suitable for CLI\-invoked exec where the user provides the full command line.

<a name="Container.Export"></a>
### func \(\*Container\) Export

```go
func (c *Container) Export(ctx context.Context, output string, entrypoint []string) error
```

Commits the container's filesystem changes and exports the result as an OCI archive.

The diff between the container's snapshot and its parent is stored as a new layer. If entrypoint is non\-empty it is set on the image config. The resulting image is written to output/image.tar. The stored image record in containerd is never modified. The mutated manifest, config, and index are written to the content store as ephemeral blobs and referenced only during the export. A content lease protects these blobs from garbage collection until the export completes.

<a name="Container.MkdirAll"></a>
### func \(\*Container\) MkdirAll

```go
func (c *Container) MkdirAll(ctx context.Context, path string) error
```

Creates a directory inside the container, including parents.

<a name="Container.Start"></a>
### func \(\*Container\) Start

```go
func (c *Container) Start(ctx context.Context) error
```

Starts a new task on an existing container.

Any leftover task from a previous run is cleaned up first. The container must already exist; use \[Container.create\] for initial creation.

<a name="Container.Status"></a>
### func \(\*Container\) Status

```go
func (c *Container) Status(ctx context.Context) (protocol.ContainerState, error)
```

Queries the current state of the container.

Returns [protocol.ContainerRunning](<https://pkg.go.dev/github.com/cruciblehq/spec/protocol/#ContainerRunning>) if the task is active, [protocol.ContainerStopped](<https://pkg.go.dev/github.com/cruciblehq/spec/protocol/#ContainerStopped>) if the container exists but has no running task, or [protocol.ContainerNotCreated](<https://pkg.go.dev/github.com/cruciblehq/spec/protocol/#ContainerNotCreated>) if the container does not exist.

<a name="Container.Stop"></a>
### func \(\*Container\) Stop

```go
func (c *Container) Stop(ctx context.Context) error
```

Stops the container's task.

The running task is killed and deleted. The container metadata is preserved. Calling Stop on an already\-stopped container is not an error.

<a name="Container.buildExportTarget"></a>
### func \(\*Container\) buildExportTarget

```go
func (c *Container) buildExportTarget(ctx context.Context, imageName string, mutate func(*ocispec.Manifest, *ocispec.Image)) (ocispec.Descriptor, error)
```

Builds the export target descriptor by applying a mutation to the image's manifest and config.

The mutated manifest, config, and \(when the root is an index\) a new single\-entry index are written to the content store as ephemeral blobs. The stored image record is never modified, so subsequent builds always see the original, clean image pulled from the registry.

<a name="Container.buildImageTarget"></a>
### func \(\*Container\) buildImageTarget

```go
func (c *Container) buildImageTarget(ctx context.Context, root ocispec.Descriptor, index *ocispec.Index, manifestIdx int, newManifest ocispec.Descriptor, imageName string) (ocispec.Descriptor, error)
```

Produces the final image target descriptor after a manifest update.

When the image was resolved through an index, a new single\-entry index is written containing only the updated manifest. Entries for other platforms are dropped because their layer blobs are typically not present in the content store \(only the target platform's layers are fetched\).

<a name="Container.buildProcessSpec"></a>
### func \(\*Container\) buildProcessSpec

```go
func (c *Container) buildProcessSpec(ctx context.Context, env []string, workdir string, args ...string) (*specs.Process, error)
```

Builds an OCI process spec for running a command inside the container.

A process spec defines everything needed to start a process: the command and arguments, environment variables, working directory, and terminal mode. The base values are copied from the container's own OCI spec, then env and workdir are overridden if provided.

<a name="Container.configPlatform"></a>
### func \(\*Container\) configPlatform

```go
func (c *Container) configPlatform(ctx context.Context, desc ocispec.Descriptor) (ocispec.Platform, bool)
```

Reads the image config referenced by a manifest descriptor and returns the platform declared in the config.

Returns false when the config cannot be read.

<a name="Container.create"></a>
### func \(\*Container\) create

```go
func (c *Container) create(ctx context.Context, image containerd.Image, extraOpts ...oci.SpecOpts) (containerd.Container, error)
```

Creates the containerd container with the standard configuration.

Spec options are applied sequentially. Each one mutates the OCI spec in place, so extraOpts appended after the base options can override values set by WithImageConfig \(last writer wins\). Build containers use this to replace the image entrypoint with "sleep infinity".

<a name="Container.execCommand"></a>
### func \(\*Container\) execCommand

```go
func (c *Container) execCommand(ctx context.Context, stdin io.Reader, stdout io.Writer, env []string, workdir string, args ...string) (int, string, error)
```

Runs a command inside the container, returning the exit code and captured stderr. Builds the process spec from args, then delegates to execProcess. A non\-zero exit code is not treated as an error; the caller decides.

<a name="Container.execProcess"></a>
### func \(\*Container\) execProcess

```go
func (c *Container) execProcess(ctx context.Context, pspec *specs.Process, stdin io.Reader, stdout, stderr io.Writer) (int, error)
```

Starts a process inside the container's running task, waits for it to exit, and returns the exit code.

The process is attached to the task as an additional exec, not as the primary process. This requires the task to already be running \(started by \[Container.startTask\] during container creation\). stdin, stdout, and stderr are connected to the process. Nil streams are replaced with io.Discard \(stdout/stderr\) or left disconnected \(stdin\). A non\-zero exit code is not treated as an error; the caller decides how to handle it.

When stdin is provided, the container's stdin is explicitly closed after the reader returns EOF so the exec process receives the EOF signal. This is required because the containerd shim holds both ends of the stdin FIFO open and will not propagate EOF on its own.

<a name="Container.exportImage"></a>
### func \(\*Container\) exportImage

```go
func (c *Container) exportImage(ctx context.Context, target ocispec.Descriptor, imageName, path string) error
```

Writes the image to an OCI tar archive at the given path.

The target descriptor is exported directly via \[archive.WithManifest\] rather than looking up the image by name. This allows the caller to export ephemeral content \(e.g., a mutated manifest with an extra layer\) without modifying the stored image record. The image name is attached as the OCI reference annotation on the archive entry. When the target is a multi\-platform index, only the manifest matching the container's platform is included.

<a name="Container.loadTask"></a>
### func \(\*Container\) loadTask

```go
func (c *Container) loadTask(ctx context.Context) (containerd.Task, error)
```

Loads the container's running task.

<a name="Container.matchManifest"></a>
### func \(\*Container\) matchManifest

```go
func (c *Container) matchManifest(ctx context.Context, idx ocispec.Index, matcher platforms.MatchComparer) (int, bool)
```

Searches the index for a manifest matching the given platform.

Descriptors with an explicit platform field are checked first. If none match, descriptors without a platform field are probed by reading the image config to discover the platform \(the "ConfigPlatform" fallback\). Returns the index position and true when a match is found.

<a name="Container.mustExec"></a>
### func \(\*Container\) mustExec

```go
func (c *Container) mustExec(ctx context.Context, desc string, stdin io.Reader, stdout io.Writer, args ...string) error
```

Helper method that runs a command inside the container, returning an error that includes desc if the process exits with a non\-zero code.

<a name="Container.mutateManifest"></a>
### func \(\*Container\) mutateManifest

```go
func (c *Container) mutateManifest(ctx context.Context, target ocispec.Descriptor, imageName string, mutate func(*ocispec.Manifest, *ocispec.Image)) (ocispec.Descriptor, error)
```

Reads the manifest and config, applies the mutation, and writes the updated blobs back to the content store.

<a name="Container.readConfig"></a>
### func \(\*Container\) readConfig

```go
func (c *Container) readConfig(ctx context.Context, desc ocispec.Descriptor) (ocispec.Image, error)
```

Loads an OCI image config from the content store.

<a name="Container.readIndex"></a>
### func \(\*Container\) readIndex

```go
func (c *Container) readIndex(ctx context.Context, desc ocispec.Descriptor) (ocispec.Index, error)
```

Loads an OCI image index from the content store.

<a name="Container.readManifest"></a>
### func \(\*Container\) readManifest

```go
func (c *Container) readManifest(ctx context.Context, desc ocispec.Descriptor) (ocispec.Manifest, error)
```

Loads an OCI manifest from the content store.

<a name="Container.remove"></a>
### func \(\*Container\) remove

```go
func (c *Container) remove(ctx context.Context)
```

Removes an existing container with this ID, if one exists.

Any running task is killed and the container is deleted along with its snapshot. This is a no\-op when no container with the ID is found.

<a name="Container.resolveManifestDescriptor"></a>
### func \(\*Container\) resolveManifestDescriptor

```go
func (c *Container) resolveManifestDescriptor(ctx context.Context, root ocispec.Descriptor, imageName string) (ocispec.Descriptor, *ocispec.Index, int, error)
```

Resolves the image root descriptor to a platform\-specific manifest.

If the root is an OCI Image Index, the index is read and walked to find the manifest matching the container's platform. Returns the manifest descriptor, the index \(nil when the root is al\+,,ready a manifest\), and the position of the manifest within the index.

Some registries \(notably Docker Hub\) serve index entries without explicit platform metadata. When a descriptor lacks a platform field, the manifest and its config are read to extract the platform from the image config, the same fallback that containerd's images.Manifest uses internally.

<a name="Container.snapshotDiff"></a>
### func \(\*Container\) snapshotDiff

```go
func (c *Container) snapshotDiff(ctx context.Context, info containers.Container) (ocispec.Descriptor, digest.Digest, error)
```

Computes the diff between the container's snapshot and its parent, returning the layer descriptor and its diff ID without modifying the image.

<a name="Container.startTask"></a>
### func \(\*Container\) startTask

```go
func (c *Container) startTask(ctx context.Context, ctr containerd.Container) error
```

Starts the container's long\-running task with no attached IO.

<a name="Container.writeBlob"></a>
### func \(\*Container\) writeBlob

```go
func (c *Container) writeBlob(ctx context.Context, mediaType string, v any, ref string, opts ...content.Opt) (ocispec.Descriptor, error)
```

Serializes a value and writes it to the content store, returning the descriptor that references the stored blob.

<a name="ExecResult"></a>
## type ExecResult

Output of a command execution inside a container.

```go
type ExecResult struct {
    ExitCode int    // Exit code of the process.
    Stdout   string // Captured standard output.
    Stderr   string // Captured standard error.
}
```

<a name="Runtime"></a>
## type Runtime

Manages the containerd client and provides image and container operations.

```go
type Runtime struct {
    client *containerd.Client // Containerd client for managing containers and images.
}
```

<a name="New"></a>
### func New

```go
func New(address, namespace string) (*Runtime, error)
```

Creates a runtime connected to the containerd socket at the given address.

The namespace scopes all containerd operations to a single tenant. The runtime must be closed when no longer needed.

<a name="Runtime.Close"></a>
### func \(\*Runtime\) Close

```go
func (rt *Runtime) Close() error
```

Closes the containerd client connection.

<a name="Runtime.Container"></a>
### func \(\*Runtime\) Container

```go
func (rt *Runtime) Container(id string) *Container
```

Returns a handle for an existing container.

The container is not loaded or verified; the handle is a lightweight reference that resolves the container lazily on subsequent calls.

<a name="Runtime.DestroyImage"></a>
### func \(\*Runtime\) DestroyImage

```go
func (rt *Runtime) DestroyImage(ctx context.Context, tag string) error
```

Removes an image and all containers created from it.

Containers are discovered by querying containerd for records whose image field matches the tag. Each container's task is killed before the container and its snapshot are deleted.

<a name="Runtime.ImportImage"></a>
### func \(\*Runtime\) ImportImage

```go
func (rt *Runtime) ImportImage(ctx context.Context, path, tag string) error
```

Imports an OCI archive, tags it under the given name, and unpacks it for the host platform.

The archive is transferred server\-side into containerd's content store, tagged with the provided name, and the layers are unpacked into the snapshotter.

<a name="Runtime.StartContainer"></a>
### func \(\*Runtime\) StartContainer

```go
func (rt *Runtime) StartContainer(ctx context.Context, path string, id string, platform string) (*Container, error)
```

Imports an OCI archive, unpacks it for the target platform, and starts a container.

The archive is transferred server\-side into containerd's content store, tagged with a deterministic name derived from the path, and the layers for the target platform are unpacked into the snapshotter. A container is created with a fresh snapshot and a long\-running task \(sleep infinity\) is started so that subsequent Exec calls have a running process to attach to. Any existing container with the same ID is removed before the new one is created. Building for a platform other than the host requires QEMU / binfmt\_misc support in the kernel.

<a name="Runtime.StartContainerFromOCI"></a>
### func \(\*Runtime\) StartContainerFromOCI

```go
func (rt *Runtime) StartContainerFromOCI(ctx context.Context, ref string, id string, platform string) (*Container, error)
```

Pulls a remote OCI image and starts a container from it.

The reference is a single\-token OCI image name such as "alpine:3.21" or "docker.io/library/alpine:3.21", normalized to include the default registry and tag when omitted. The image is pulled into containerd's content store, unpacked for the target platform, and a container with a long\-running task is started. Any existing container with the same ID is removed before the new one is created.

<a name="Runtime.StartFromTag"></a>
### func \(\*Runtime\) StartFromTag

```go
func (rt *Runtime) StartFromTag(ctx context.Context, tag, id string) (*Container, error)
```

Starts a container from a previously imported image tag.

The operation is idempotent: if the container is already running it is left untouched; if the container exists but has no active task a new task is started on the existing snapshot; otherwise a new container is created from the image.

<a name="Runtime.pullImage"></a>
### func \(\*Runtime\) pullImage

```go
func (rt *Runtime) pullImage(ctx context.Context, ref string, platform string) (containerd.Image, error)
```

Pulls a remote OCI image from a container registry.

The reference is a single\-token image name. Bare names like "alpine:3.21" are normalized to "docker.io/library/alpine:3.21", and untagged names receive the "latest" tag. This differs from Crucible references, which are space\-separated name and version strings resolved by the CLI before reaching the daemon. The image is stored in containerd's content store and unpacked into the snapshotter for the specified platform.

Uses the containerd transfer service rather than the lower\-level Pull or Fetch APIs. The transfer service handles multi\-platform index resolution correctly, including index entries whose descriptors lack explicit platform metadata \(as seen in some Docker Official Images\).

If the image is already present and unpacked for the target platform the pull is skipped, avoiding unnecessary registry requests \(e.g. when Docker Hub rate limits are in effect\).

<a name="Runtime.resolveImage"></a>
### func \(\*Runtime\) resolveImage

```go
func (rt *Runtime) resolveImage(ctx context.Context, tag, platform string) (containerd.Image, error)
```

Looks up a tagged image and selects the manifest for the given platform.

Multi\-platform images contain manifests for multiple architectures. This method selects one, so that subsequent operations target the correct architecture.

<a name="Runtime.transferImage"></a>
### func \(\*Runtime\) transferImage

```go
func (rt *Runtime) transferImage(ctx context.Context, path, tag, platform string) error
```

Transfers an OCI archive into containerd's content store server\-side.

The archive is streamed to containerd which imports it, stores it under the given tag, and unpacks the layers for the target platform into the snapshotter. The entire operation runs inside the containerd process, so cruxd does not need mount privileges.

<a name="doneReader"></a>
## type doneReader

Wraps an [io.Reader](<https://pkg.go.dev/io/#Reader>) and signals when it returns [io.EOF](<https://pkg.go.dev/io/#EOF>).

The done channel is closed exactly once on the first EOF, making it safe to use from multiple goroutines.

```go
type doneReader struct {
    r    io.Reader
    once sync.Once
    done chan struct{}
}
```

<a name="newDoneReader"></a>
### func newDoneReader

```go
func newDoneReader(r io.Reader) *doneReader
```

Creates a new \[doneReader\] wrapping the given reader.

<a name="doneReader.Read"></a>
### func \(\*doneReader\) Read

```go
func (d *doneReader) Read(p []byte) (int, error)
```

Delegates to the underlying reader.

Closes the done channel on the first [io.EOF](<https://pkg.go.dev/io/#EOF>). Non\-EOF errors are returned without closing the channel.

# server

```go
import "github.com/cruciblehq/cruxd/internal/server"
```

Package server implements the cruxd daemon.

The daemon listens on a Unix domain socket for JSON\-encoded commands from the crux CLI. Each connection carries a single request\-response exchange: the client sends a newline\-delimited JSON envelope, the server dispatches the command, and writes the result back before closing the connection.

Supported commands include building resources, querying daemon status, and initiating shutdown. Build commands are delegated to the build package, which in turn uses the runtime package for container operations against containerd.

Example usage:

```
srv, err := server.New(server.Config{
    ContainerdAddress:   "/run/containerd/containerd.sock",
    ContainerdNamespace: "crucible",
})
if err != nil {
    return err
}

if err := srv.Start(); err != nil {
    return err
}
defer srv.Stop()

srv.Wait()
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func contextWithDisconnect\(parent context.Context, r io.Reader\) \(context.Context, context.CancelFunc\)](<#contextWithDisconnect>)
- [func listen\(socketPath string\) \(net.Listener, error\)](<#listen>)
- [func setSocketPermissions\(socketPath string\) error](<#setSocketPermissions>)
- [func writePID\(\) error](<#writePID>)
- [type Config](<#Config>)
- [type Server](<#Server>)
  - [func New\(cfg Config\) \(\*Server, error\)](<#New>)
  - [func \(s \*Server\) Start\(\) error](<#Server.Start>)
  - [func \(s \*Server\) Stop\(\) error](<#Server.Stop>)
  - [func \(s \*Server\) Wait\(\)](<#Server.Wait>)
  - [func \(s \*Server\) accept\(\)](<#Server.accept>)
  - [func \(s \*Server\) dispatch\(ctx context.Context, conn net.Conn, cmd protocol.Command, payload json.RawMessage\)](<#Server.dispatch>)
  - [func \(s \*Server\) handle\(conn net.Conn\)](<#Server.handle>)
  - [func \(s \*Server\) handleBuild\(ctx context.Context, conn net.Conn, payload json.RawMessage\)](<#Server.handleBuild>)
  - [func \(s \*Server\) handleContainerDestroy\(ctx context.Context, conn net.Conn, payload json.RawMessage\)](<#Server.handleContainerDestroy>)
  - [func \(s \*Server\) handleContainerExec\(ctx context.Context, conn net.Conn, payload json.RawMessage\)](<#Server.handleContainerExec>)
  - [func \(s \*Server\) handleContainerStatus\(ctx context.Context, conn net.Conn, payload json.RawMessage\)](<#Server.handleContainerStatus>)
  - [func \(s \*Server\) handleContainerStop\(ctx context.Context, conn net.Conn, payload json.RawMessage\)](<#Server.handleContainerStop>)
  - [func \(s \*Server\) handleContainerUpdate\(ctx context.Context, conn net.Conn, payload json.RawMessage\)](<#Server.handleContainerUpdate>)
  - [func \(s \*Server\) handleImageDestroy\(ctx context.Context, conn net.Conn, payload json.RawMessage\)](<#Server.handleImageDestroy>)
  - [func \(s \*Server\) handleImageImport\(ctx context.Context, conn net.Conn, payload json.RawMessage\)](<#Server.handleImageImport>)
  - [func \(s \*Server\) handleImageStart\(ctx context.Context, conn net.Conn, payload json.RawMessage\)](<#Server.handleImageStart>)
  - [func \(s \*Server\) handleShutdown\(\_ context.Context, conn net.Conn\)](<#Server.handleShutdown>)
  - [func \(s \*Server\) handleStatus\(\_ context.Context, conn net.Conn\)](<#Server.handleStatus>)
  - [func \(s \*Server\) respond\(conn net.Conn, cmd protocol.Command, payload any\)](<#Server.respond>)


## Constants

<a name="DefaultContainerdAddress"></a>

```go
const (

    // Default containerd socket address.
    DefaultContainerdAddress = "/run/containerd/containerd.sock"

    // Default containerd namespace for images and containers.
    DefaultContainerdNamespace = "cruxd"

    // Group name used to grant socket access. Members of this group can
    // connect to the daemon socket without owning the process.
    socketGroup = "cruxd"

    // File mode applied to the Unix socket. Owner and group get read-write
    // (required for connect); others get no access.
    socketMode = 0660
)
```

## Variables

<a name="ErrServer"></a>

```go
var (
    ErrServer = errors.New("server error")
)
```

<a name="contextWithDisconnect"></a>
## func contextWithDisconnect

```go
func contextWithDisconnect(parent context.Context, r io.Reader) (context.Context, context.CancelFunc)
```

Returns a derived context that is cancelled when the remote end of the connection closes.

Detection works by reading from r in a background goroutine. The read blocks until the peer closes the connection, at which point it returns an error and the derived context is cancelled. The caller must ensure that no further data is expected on r for the lifetime of the returned context. If data arrives unexpectedly, it will be discarded and the context will be cancelled prematurely. The returned [context.CancelFunc](<https://pkg.go.dev/context/#CancelFunc>) must always be called to release resources, even if the connection closes on its own.

<a name="listen"></a>
## func listen

```go
func listen(socketPath string) (net.Listener, error)
```

Creates the Unix socket listener, removes any stale socket from a previous run, and applies permissions.

<a name="setSocketPermissions"></a>
## func setSocketPermissions

```go
func setSocketPermissions(socketPath string) error
```

Restricts socket access to owner and group. The daemon does not run as root; any user in the cruxd group can also connect.

<a name="writePID"></a>
## func writePID

```go
func writePID() error
```

Writes the daemon PID to the PID file so the CLI can detect whether the daemon is already running and send it signals.

<a name="Config"></a>
## type Config

Holds server configuration.

```go
type Config struct {
    SocketPath          string // Override for the Unix socket path. Empty uses the default.
    ContainerdAddress   string // Containerd socket address. Empty uses [DefaultContainerdAddress].
    ContainerdNamespace string // Containerd namespace for images and containers. Empty uses [DefaultContainerdNamespace].
}
```

<a name="Server"></a>
## type Server

Listens on a Unix domain socket and dispatches commands.

```go
type Server struct {
    socketPath string           // Path to the Unix socket file.
    runtime    *runtime.Runtime // Containerd-backed container runtime.
    listener   net.Listener     // Listener for incoming connections.
    startedAt  time.Time        // Timestamp when the server started.
    builds     int              // Total number of build commands processed.
    done       chan struct{}    // Channel to signal server shutdown.
    mu         sync.Mutex       // Mutex to protect shared state.
}
```

<a name="New"></a>
### func New

```go
func New(cfg Config) (*Server, error)
```

Creates a new server instance.

The socket is not opened until \[Start\] is called.

<a name="Server.Start"></a>
### func \(\*Server\) Start

```go
func (s *Server) Start() error
```

Opens the Unix socket and begins accepting connections.

<a name="Server.Stop"></a>
### func \(\*Server\) Stop

```go
func (s *Server) Stop() error
```

Shuts down the server and cleans up resources.

<a name="Server.Wait"></a>
### func \(\*Server\) Wait

```go
func (s *Server) Wait()
```

Blocks until the server stops.

<a name="Server.accept"></a>
### func \(\*Server\) accept

```go
func (s *Server) accept()
```

Accepts connections in a loop until the server shuts down.

<a name="Server.dispatch"></a>
### func \(\*Server\) dispatch

```go
func (s *Server) dispatch(ctx context.Context, conn net.Conn, cmd protocol.Command, payload json.RawMessage)
```

Routes a command to the appropriate handler.

<a name="Server.handle"></a>
### func \(\*Server\) handle

```go
func (s *Server) handle(conn net.Conn)
```

Processes a single connection.

Reads one newline\-delimited JSON message, dispatches the command, and writes the response. The connection is closed after one exchange.

<a name="Server.handleBuild"></a>
### func \(\*Server\) handleBuild

```go
func (s *Server) handleBuild(ctx context.Context, conn net.Conn, payload json.RawMessage)
```

Handles a build command.

Receives a recipe from crux and executes it against the container runtime.

<a name="Server.handleContainerDestroy"></a>
### func \(\*Server\) handleContainerDestroy

```go
func (s *Server) handleContainerDestroy(ctx context.Context, conn net.Conn, payload json.RawMessage)
```

Handles a container\-destroy command.

<a name="Server.handleContainerExec"></a>
### func \(\*Server\) handleContainerExec

```go
func (s *Server) handleContainerExec(ctx context.Context, conn net.Conn, payload json.RawMessage)
```

Handles a container\-exec command.

<a name="Server.handleContainerStatus"></a>
### func \(\*Server\) handleContainerStatus

```go
func (s *Server) handleContainerStatus(ctx context.Context, conn net.Conn, payload json.RawMessage)
```

Handles a container\-status command.

<a name="Server.handleContainerStop"></a>
### func \(\*Server\) handleContainerStop

```go
func (s *Server) handleContainerStop(ctx context.Context, conn net.Conn, payload json.RawMessage)
```

Handles a container\-stop command.

<a name="Server.handleContainerUpdate"></a>
### func \(\*Server\) handleContainerUpdate

```go
func (s *Server) handleContainerUpdate(ctx context.Context, conn net.Conn, payload json.RawMessage)
```

Handles a container\-update command.

<a name="Server.handleImageDestroy"></a>
### func \(\*Server\) handleImageDestroy

```go
func (s *Server) handleImageDestroy(ctx context.Context, conn net.Conn, payload json.RawMessage)
```

Handles an image\-destroy command.

<a name="Server.handleImageImport"></a>
### func \(\*Server\) handleImageImport

```go
func (s *Server) handleImageImport(ctx context.Context, conn net.Conn, payload json.RawMessage)
```

Handles an image\-import command.

<a name="Server.handleImageStart"></a>
### func \(\*Server\) handleImageStart

```go
func (s *Server) handleImageStart(ctx context.Context, conn net.Conn, payload json.RawMessage)
```

Handles an image\-start command.

<a name="Server.handleShutdown"></a>
### func \(\*Server\) handleShutdown

```go
func (s *Server) handleShutdown(_ context.Context, conn net.Conn)
```

Handles a shutdown command.

<a name="Server.handleStatus"></a>
### func \(\*Server\) handleStatus

```go
func (s *Server) handleStatus(_ context.Context, conn net.Conn)
```

Handles a status command.

<a name="Server.respond"></a>
### func \(\*Server\) respond

```go
func (s *Server) respond(conn net.Conn, cmd protocol.Command, payload any)
```

Writes a JSON envelope response to the connection.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
